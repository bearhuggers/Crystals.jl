<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Catalogue · Crystals.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>Crystals.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="basic.html">Basic Usage</a></li><li><a class="toctext" href="cartesian.html">Cartesian and Fractional Coordinates</a></li><li class="current"><a class="toctext" href="methods.html">API Catalogue</a><ul class="internal"><li><a class="toctext" href="#Querying-and-property-methods-1">Querying and property methods</a></li><li><a class="toctext" href="#Looping-1">Looping</a></li><li><a class="toctext" href="#Modifying,-building-up-and-building-down-1">Modifying, building up and building down</a></li><li><a class="toctext" href="#Point-group,-space-group,-and-geometry-1">Point-group, space-group, and geometry</a></li><li><a class="toctext" href="#Predefined-lattices-1">Predefined lattices</a></li><li><a class="toctext" href="#Output-and-Logging-1">Output and Logging</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="methods.html">API Catalogue</a></li></ul><a class="edit-page" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/docs/src/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h2><a class="nav-anchor" id="Querying-and-property-methods-1" href="#Querying-and-property-methods-1">Querying and property methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Structures.is_fractional" href="#Crystals.Structures.is_fractional"><code>Crystals.Structures.is_fractional</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">is_fractional(crystal)
</code></pre><p>True if the crystal structure is fractional.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Structures.jl#L90-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Structures.are_compatible_lattices" href="#Crystals.Structures.are_compatible_lattices"><code>Crystals.Structures.are_compatible_lattices</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">are_compatible_lattices(lattices...)</code></pre><p>True if the lattices are mathematically equivalent. Two lattices are equivalent if they represent the same periodicity. In practice, this means the two lattices have the same volume, and their cell vectors are integer linear combinations of one another.</p><p><strong>Parameters</strong></p><ul><li><p><code>lattices::Vararg{Union{Matrix, Crystal}}</code>: Any number of lattices</p></li><li><p><code>digits::Integer</code>: when checking the cells are integer co-linear, the product <span>$A^{-1}B$</span> is first rounded to this number of digits</p></li><li><p><code>rtol::Real</code>: relative tolerance when checking the volumes correspond (no units). Default to 1.0e-8.</p></li><li><p><code>atol::Real</code>: absolute tolerance when checking the volumes correspond (no units). Default to 1.0e-8.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Crystals, Unitful
crystal = Crystal([0 2.1 2.1; 2.1 0 2.1; 2.1 2.1 0]u&quot;nm&quot;)
cells = Matrix{Int64}[eye(3)]
while length(cells) &lt; 5
    cell = rand(-5:5, (3, 3))
    volume(cell) == 1 &amp;&amp; push!(cells, cell)
end
lattices = [crystal.cell * c for c in cells]
are_compatible_lattices(crystal, lattices...)

# output
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Structures.jl#L143-L176">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Structures.volume" href="#Crystals.Structures.volume"><code>Crystals.Structures.volume</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">volume(crystal)
</code></pre><p>Returns the volume of a <code>Crystal</code> instance or of a cell. It comes down to computing <span>$|det(A)|$</span> where <span>$A$</span> is the crystal cell.</p><p><strong>Examples</strong></p><pre><code class="language-jlcon">julia&gt; using Crystals

julia&gt; volume(Crystal([0 2 2; 2 0 2; 2 2 0]u&quot;nm&quot;))
16.0 nm^3

julia&gt; volume([0 2 2; 2 0 2; 2 2 0]u&quot;nm&quot;)
16.0 nm^3

julia&gt; volume([0 2 2; 2 0 2; 2 2 0])
16.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Structures.jl#L106-L126">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.cell_parameters" href="#Crystals.Utilities.cell_parameters"><code>Crystals.Utilities.cell_parameters</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cell_parameters(a::Quantity, b::Quantity, c::Quantity,
                α::Quantity=(π/2)u&quot;rad&quot;, β::Quantity=(π/2)u&quot;rad&quot;,
                γ::Quantity=(π/2)u&quot;rad&quot;)</code></pre><p>Computes the cell matrix from the cell parameters [a, b, c, α, β, γ].</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L301-L307">source</a><br/><div><pre><code class="language-none">cell_parameters(cell::AbstractMatrix)
cell_parameters(cell::Crystal)</code></pre><p>Parameters (a, b, c, α, β, γ) of the input cell returned in a named tuple.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L323-L328">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Gruber.gruber" href="#Crystals.Gruber.gruber"><code>Crystals.Gruber.gruber</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gruber(cell::Matrix;
       tolerance::Real=default_tolerance, itermax::Unsigned=50,
       max_no_change::Unsigned=10)</code></pre><p>Determines Gruber cell of an input cell.</p><p>The Gruber cell is an optimal parameterization of a lattice, e.g. shortest cell-vectors and angles closest to 90 degrees. The new cell is in the same basis as the origin cell: no rotation has been incurred. The cell parameters are uniquely determined, even though the cell itself is not (certain symmetry operations leaving the structure unchanged may yield a more recognizable cell). If you want a unique Cartesian cell (in a different Cartesian basis), use the <code>niggly</code> algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>cell::Matrix</code>: the input lattice cell-vectors. Cannot be singular.</p></li><li><p><code>itermax::Integer</code>: maximum number of iterations before bailing out</p></li><li><p><code>tolerance::Number</code>: tolerance parameter when comparing real numbers</p></li><li><p><code>max_no_change::Integer</code>: Maximum number of times to go through algorithm without changes before bailing out</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Gruber.jl#L110-L131">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Gruber.niggly" href="#Crystals.Gruber.niggly"><code>Crystals.Gruber.niggly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">niggly(cell::Matrix; kwargs...)</code></pre><p>Determines a unique Cartesian cell equivalent to the input, with the shortest possible vectors and squarest angles. For an explanation of the parameters, see <code>gruber</code>. In practice, this function computes the cell-parameters of a <code>gruber</code> cell and then reconstructs the cell matrix. Hence, the result should be quite unique for any lattice representation, including any rotation of the underlying Cartesian coordinates.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Gruber.jl#L204-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.is_periodic" href="#Crystals.Utilities.is_periodic"><code>Crystals.Utilities.is_periodic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">is_periodic(a::AbstractVector, b::AbstractVector, cell::AbstractMatrix;
            tolerance::Real=1.0e-8)</code></pre><p>True if the positions are one-to-one periodic with respect to the input cell.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L158-L163">source</a><br/><div><pre><code class="language-none">is_periodic(a::AbstractMatrix, b::AbstractVector, cell::AbstractMatrix;
            tolerance::Real=1.0e-8)</code></pre><p>Array of boolean describing whether positions in <code>a</code> are periodic with positions in <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L172-L177">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.SpaceGroup.is_primitive" href="#Crystals.SpaceGroup.is_primitive"><code>Crystals.SpaceGroup.is_primitive</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">is_primitive(cartesian::AbstractMatrix, cell::AbstractMatrix, species::AbstractVector;
             tolerance::Real=1.0e-8)
is_primitive(crystal::Crystal, col::Union{Symbol, AbstractVector{Symbol}}; kwargs...)
is_primitive(crystal::Crystal; kwargs...)</code></pre><p>True if the crystal structure is primitive, e.g. not a supercell, e.g. not reducible to an equivalent lattice with fewer atoms.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/SpaceGroup.jl#L190-L198">source</a><br/></section><p>Typical container and DataFrame methods are also available, such as <code>names</code>, <code>size</code>, <code>ndims</code>, <code>nrow</code>, <code>ncol</code>, <code>endof</code>.</p><h2><a class="nav-anchor" id="Looping-1" href="#Looping-1">Looping</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.CrystalAtoms.eachatom" href="#Crystals.CrystalAtoms.eachatom"><code>Crystals.CrystalAtoms.eachatom</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Iterator over each atom in the crystal </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/CrystalAtoms.jl#L30">source</a><br/></section><p><code>eachindex</code> is also available. It returns the range over atoms indices <code>1:size(crystal, 1)</code>.</p><h2><a class="nav-anchor" id="Modifying,-building-up-and-building-down-1" href="#Modifying,-building-up-and-building-down-1">Modifying, building up and building down</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.round" href="#Base.round"><code>Base.round</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">round(crystal, args)
</code></pre><p>Rounds the cell and positions of a crystal. See <code>Base.round</code> for possible parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Crystals
crystal = Crystal([0 0.501 0.501; 0.496 0.001 0.497; 0.497 0.497 0]u&quot;nm&quot;,
                  position=[0.001, -0.001, -0.001]u&quot;nm&quot;,
                  position=[0.25, 0.251, -0.247]u&quot;nm&quot;)
round(crystal, 2)

# output

cell(nm):
  0.0 0.5 0.5
  0.5 0.0 0.5
  0.5 0.5 0.0
│ Atom │ Cartesian         │
├──────┼───────────────────┤
│ 1    │ (0.0,-0.0,-0.0)   │
│ 2    │ (0.25,0.25,-0.25) │</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Structures.jl#L659-L684">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Structures.round!" href="#Crystals.Structures.round!"><code>Crystals.Structures.round!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">round!(crystal, args)
</code></pre><p>Rounds the cell and positions of a crystal. See <code>round</code> for possible parameters.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Structures.jl#L640-L644">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.into_cell" href="#Crystals.Utilities.into_cell"><code>Crystals.Utilities.into_cell</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">into_cell(pos, cell; tolerance)
</code></pre><p>Folds periodic positions into cell</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L203-L207">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.into_voronoi" href="#Crystals.Utilities.into_voronoi"><code>Crystals.Utilities.into_voronoi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">into_voronoi(positions::AbstractArray, cell::AbstractMatrix; extent::Integer=1)</code></pre><p>Folds positions into first Brillouin zone of the input cell. Makes a well-meaning effort at returning the periodic image with the smallest possible norm. It recenter the atoms around the origin and then looks for the smallest periodic images within <code>-extent:extent</code> cells. If the cell is quite pathological, then the result will not be within the Voronoi cell.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L233-L240">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.origin_centered" href="#Crystals.Utilities.origin_centered"><code>Crystals.Utilities.origin_centered</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">origin_centered(positions::AbstractArrays, cell::AbstractMatrix)</code></pre><p>Folds positions back to origin, such that each fractional component <span>$x_f$</span> is between <span>$-0.5\leq x_f &lt; 0.5$</span>. If the input is in Cartesian (fractional) coordinates, then the result is also in Cartesian (fractional) coordinates.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L222-L228">source</a><br/></section><p><a href="methods.html#Crystals.SpaceGroup.is_primitive"><code>is_primitive</code></a> can be queried to figure out whether a crystal is a primitive cell or a supercell.</p><h2><a class="nav-anchor" id="Point-group,-space-group,-and-geometry-1" href="#Point-group,-space-group,-and-geometry-1">Point-group, space-group, and geometry</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.SpaceGroup.point_group" href="#Crystals.SpaceGroup.point_group"><code>Crystals.SpaceGroup.point_group</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Finds and stores point group operations for a given lattice</p><p>A lattice is defined by a 3x3 matrix or cell.  Rotations are determined from G-vector triplets with the same norm as the unit-cell vectors.</p><p>Implementation taken from <a href="http://enum.sourceforge.net/">ENUM</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/SpaceGroup.jl#L47-L54">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.SpaceGroup.space_group" href="#Crystals.SpaceGroup.space_group"><code>Crystals.SpaceGroup.space_group</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">space_group(crystal; kwargs...)
</code></pre><p>Computes the space-group operations of a crystal. By default, all atomic properties are considered when determining whether atomic sites are related by symmetry. However, it is possible to specify a subset of atomic properties. An empty subset of atomic properties implies that all atoms sites are equivalent. It is also possible to specify an array of integers, serving as labels for each atomic site.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/SpaceGroup.jl#L353-L361">source</a><br/><div><pre><code class="language-julia">space_group(cell, positions, species; kwargs...)
</code></pre><pre><code class="language-none">Computes the space-group of a crystal specified using standard Julia types.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/SpaceGroup.jl#L376-L380">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.hart_forcade" href="#Crystals.Utilities.hart_forcade"><code>Crystals.Utilities.hart_forcade</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">hart_forcade(lattice, supercell; digits)
</code></pre><p>Computes the cyclic group of a supercell with respect to a lattice. It makes it possible to identify the class of periodically equivalent cell that a given position within the supercell belongs to. The function returns a named tuple with the transform and the quotient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Crystals, Unitful
fcc = [0 0.5 0.5; 0.5 0 0.5; 0.5 0.5 0]u&quot;nm&quot;
supercell = [0 2 2; 0 -4 2; -1 0 -2]
ht = hart_forcade(fcc, fcc * supercell)

println(ht)
println(&quot;Positions in supercell:&quot;)
for index in CartesianRange((ht.quotient...))
    position = inv(ht.transform) * [index[u] for u in eachindex(ht.quotient)]
    println(&quot;- &quot;, ustrip(position), &quot; (&quot;, unit(eltype(position)), &quot;)&quot;)
end

# output

Hart-Forcade transform
- transform (nm^-1): [-1.0 -1.0 1.0; -1.0 1.0 1.0; -1.0 1.0 3.0]
- quotient: [1,2,6]

Positions in supercell:
- [-1.0,0.0,0.0] (nm)
- [-2.0,0.5,-0.5] (nm)
- [-0.5,0.0,0.5] (nm)
- [-1.5,0.5,0.0] (nm)
- [0.0,0.0,1.0] (nm)
- [-1.0,0.5,0.5] (nm)
- [0.5,0.0,1.5] (nm)
- [-0.5,0.5,1.0] (nm)
- [1.0,0.0,2.0] (nm)
- [0.0,0.5,1.5] (nm)
- [1.5,0.0,2.5] (nm)
- [0.5,0.5,2.0] (nm)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.SpaceGroup.primitive" href="#Crystals.SpaceGroup.primitive"><code>Crystals.SpaceGroup.primitive</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">primitive(crystal::Crystal; tolerance::Real=1.0e-8)</code></pre><p>Computes the primitive cell of the input crystal. If the crystal is primitive, it is returned as is, otherwise a new crystal is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/SpaceGroup.jl#L210-L215">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Utilities.supercell" href="#Crystals.Utilities.supercell"><code>Crystals.Utilities.supercell</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">supercell(lattice, supercell; site_id, tolerance)
</code></pre><p>Creates a supercell from an input lattice.</p><p># Parameters</p><ul><li><p><code>lattice::Crystal</code>: the original lattice</p></li><li><p><code>supercell::AbstractMatrix</code>: the cell of the supercell in Cartesian coordinates</p></li><li><p><code>site_id::Bool</code>: Whether to add/modify an atomic property indicating the index of the site in the original lattice</p></li><li><p><code>cell_id::Bool</code>: Whether to add/modify an atomic property indicating the index of the cell the site belongs to</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/utilities.jl#L259-L272">source</a><br/></section><h2><a class="nav-anchor" id="Predefined-lattices-1" href="#Predefined-lattices-1">Predefined lattices</a></h2><p>A small number of standard lattices are available for construction in the exported <code>Lattices</code> submodule.</p><p>For instance, the body-centered lattice:</p><div><pre><code class="language-julia">using Crystals
Lattices.bcc()</code></pre><pre><code class="language-none">cell(nm):
  -0.5 0.5 0.5
  0.5 -0.5 0.5
  0.5 0.5 -0.5
│ Atom │ Cartesian     │
├──────┼───────────────┤
│ 1    │ (0.0,0.0,0.0) │</code></pre></div><p>Or more complex lattices, such as b5 spinels:</p><div><pre><code class="language-julia">Lattices.b5()</code></pre><pre><code class="language-none">cell(nm):
  0.0 0.5 0.5
  0.5 0.0 0.5
  0.5 0.5 0.0
│ Atom │ Cartesian           │ species │
├──────┼─────────────────────┼─────────┤
│ 1    │ (0.5,0.5,0.5)       │ &#39;A&#39;     │
│ 2    │ (0.5,0.25,0.25)     │ &#39;A&#39;     │
│ 3    │ (0.25,0.5,0.25)     │ &#39;A&#39;     │
│ 4    │ (0.25,0.25,0.5)     │ &#39;A&#39;     │
│ 5    │ (0.875,0.875,0.875) │ &#39;B&#39;     │
│ 6    │ (0.125,0.125,0.125) │ &#39;B&#39;     │
│ 7    │ (0.25,0.25,0.25)    │ &#39;X&#39;     │
│ 8    │ (0.25,0.5,0.5)      │ &#39;X&#39;     │
│ 9    │ (0.5,0.25,0.5)      │ &#39;X&#39;     │
│ 10   │ (0.5,0.5,0.25)      │ &#39;X&#39;     │
│ 11   │ (0.75,0.75,0.75)    │ &#39;X&#39;     │
│ 12   │ (0.75,0.5,0.5)      │ &#39;X&#39;     │
│ 13   │ (0.5,0.75,0.5)      │ &#39;X&#39;     │
│ 14   │ (0.5,0.5,0.75)      │ &#39;X&#39;     │</code></pre></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.b5" href="#Crystals.Lattices.b5"><code>Crystals.Lattices.b5</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">b5(T; unit)
b5()
</code></pre><p>b5 (spinel) lattice </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/A2BX4.jl#L1-L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.bcc" href="#Crystals.Lattices.bcc"><code>Crystals.Lattices.bcc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">bcc(T; unit)
bcc()
</code></pre><p>Creates a body-centered lattice with a single site </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Bravais.jl#L1-L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.diamond" href="#Crystals.Lattices.diamond"><code>Crystals.Lattices.diamond</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">diamond()
diamond(T; unit)
</code></pre><p>Diamond lattice </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Binary.jl#L16-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.fcc" href="#Crystals.Lattices.fcc"><code>Crystals.Lattices.fcc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">fcc(T; unit)
fcc()
</code></pre><p>Creates an face centered lattice with a single site </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Bravais.jl#L7-L11">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.rock_salt" href="#Crystals.Lattices.rock_salt"><code>Crystals.Lattices.rock_salt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">rock_salt()
rock_salt(T; unit)
</code></pre><p>Rock-salt lattice </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Binary.jl#L1-L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.wurtzite" href="#Crystals.Lattices.wurtzite"><code>Crystals.Lattices.wurtzite</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">wurtzite()
wurtzite(T; unit)
</code></pre><p>Wurtzite lattice </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Binary.jl#L22-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Lattices.zinc_blende" href="#Crystals.Lattices.zinc_blende"><code>Crystals.Lattices.zinc_blende</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">zinc_blende()
zinc_blende(T; unit)
</code></pre><p>Zinc-blende lattice </p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Binary.jl#L9-L13">source</a><br/></section><h2><a class="nav-anchor" id="Output-and-Logging-1" href="#Output-and-Logging-1">Output and Logging</a></h2><p>Information and errors during calculations are displayed using an internal log provided by <a href="https://www.github.com/WestleyArgentum/Lumberjack.jl">Lumberjack</a>. By default, only critical errors result in output. The verbosity can be set manually.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Crystals.Log.set_log_level" href="#Crystals.Log.set_log_level"><code>Crystals.Log.set_log_level</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">set_log_level(level)
set_log_level()
</code></pre><p>Modifies log-level of all &quot;trucks&quot; in Crystals logs. The input should be one of &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, from least to most verbose.</p></div><a class="source-link" target="_blank" href="https://github.com/mdavezac/Crystals.jl/tree/7689cf76f8f343d3df993c19585f20520a7d87eb/src/Logging.jl#L32-L37">source</a><br/></section><footer><hr/><a class="previous" href="cartesian.html"><span class="direction">Previous</span><span class="title">Cartesian and Fractional Coordinates</span></a></footer></article></body></html>
